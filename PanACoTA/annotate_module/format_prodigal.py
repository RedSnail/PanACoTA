#!/usr/bin/env python3
# coding: utf-8

"""
Functions to convert prodigal result files to gembase format.

    * Proteins: multifasta with all CDS in aa
    * Replicons: multifasta of genome
    * Genes: multifasta of all genes in nuc
    * gff3: gff files without sequence
    * LSTINFO: information on annotation. Columns are: "start end strand type locus
    gene_name | product | EC_number | inference2" and strain is C (complement) or D (direct).
    Locus is: `<genome_name>.<contig_num><i or b>_<protein_num>`
    For prodigal: "start end strand type locus NA | NA | NA | NA", as no functional annotation.

@author gem
April 2019
"""

import os
import shutil

import PanACoTA.utils as utils
import PanACoTA.annotate_module.general_format_functions as gfunc


def format_one_genome(gpath, name, prod_path, lst_dir, prot_dir, gene_dir,
                      rep_dir, gff_dir, logger):
    """
     Format the given genome, and create its corresponding files in the following folders:

    - Proteins
    - Genes
    - Replicons
    - LSTINFO
    - gff

    Parameters
    ----------
    gpath : str
        path to the genome sequence which was given to prodigal for annotation
    name : str
        gembase name of the genome
    prod_path : str
        directory where prodigal folders are saved
    name : str
        gembase name of the genome
    lst_dir : srt
        path to LSTINFO folder
    prot_dir : str
        path to Proteins folder
    gene_dir : str
        path to Genes folder
    rep_dir : str
        path to Replicons folder
    gff_dir : str
        path to gff3 folder
    logger : logging.Logger
        logger object to write log information

    Returns
    -------
    bool :
        True if genome was correctly formatted, False otherwise
    """
    prodigal_dir = os.path.join(prod_path, os.path.basename(gpath) + "-prodigalRes")
    prot_file = os.path.join(prodigal_dir, name + ".faa")
    gen_file = os.path.join(prodigal_dir, name + ".ffn")
    gff_file = os.path.join(prodigal_dir, name + ".gff")

    res_prot_file = os.path.join(prot_dir, name + ".prt")
    res_gene_file = os.path.join(gene_dir, name + ".gen")
    res_lst_file = os.path.join(lst_dir, name + ".lst")
    res_rep_file = os.path.join(rep_dir, name + ".fna")
    res_gff_file = os.path.join(gff_dir, name + ".gff")


    # First, create gen and lst files, and get genome contig names
    ok = create_gene_lst(gen_file, res_gene_file, res_lst_file, name, logger)
    if not ok:
        os.remove(res_gene_file)
        os.remove(res_lst_file)
        logger.error("Problems while generating gene and lst files for {}".format(name))
        return False

    # Create replicon file. Same as input sequence but with gembase formatted headers
    ok = create_rep_gff(gpath, res_rep_file, res_gff_file, res_lst_file, gff_file, name, logger)

    ok = create_prt(prot_file, res_prot_file, res_lst_file, logger)
    # utils.rename_genome_contigs(gembase_name, gpath, outfile):\


def create_gene_lst(gen_file, res_gene_file, res_lst_file, name, logger):
    """
    Generate .gen file, from sequences contained in .ffn, but changing the
    headers to match with gembase format.
    At the same time, generate lst file

    Parameters
    ----------
    gen_file : str
        .ffn file generated by prodigal
    res_gene_file : str
        output file, to write in Genes directory
    res_lst_file : str
        .lst file to write in LSTINFO directory
    name : str
        name of the genome to format
    logger : logging.Logger
        logger object to put information

    Returns
    -------
    bool :
        True if conversion went well, False otherwise
    """

    # Variable which will contain the current sequence
    seq = ""
    # number of the current gene (first gene is 1, 2nd is 2 etc. each number is unique: do not
    # re-start at 1 for each new contig)
    locus_num = 1
    # contig number of the last gene. To check if we are now in a new contig (-> loc = b) or not
    prev_cont_num = 0
    # Keep start, strand and end from the previous gene, before overwriting it with the new one
    prev_start = ""
    prev_end = ""
    prev_strand = ""
    prev_annot = ""
    # Update loc when contig changes
    prev_loc = "b"
    loc = "b"

    # Open files: ffn prodigal to read, .gen and .lst gembase to create
    with open(gen_file, "r") as ffn, open(res_gene_file, "w") as r_gen,\
         open(res_lst_file, "w") as r_lst:
        # Read all lines in ffn file (sequences in nuc. for each gene)
        for lineffn in ffn:
            # If it is a sequence, save it and go to next line
            if not lineffn.startswith(">"):
                seq += lineffn
                continue
            # Otherwise, write header of previous sequence, write previous sequence,
            # and update for next gene
            else:
                # Get information given for the new gene (by ffn file from prodigal)
                (gname, start, end, strand, annot) = lineffn.strip().split(">")[-1].split("#")

                # Get contig number from prodigal gene header: prodigal first part of header is:
                #  <original genome name>_<contig number>_protein number
                contig_num = int(gname.strip().split("_")[-2])
                # If first gene of a new contig, previous gene was the last of
                # its contig -> prev_loc = "b"
                if contig_num != prev_cont_num:
                    prev_loc = 'b'
                    loc = 'b'
                # If not new contig. If loc == 'b', this is the first protein of this contig
                # Next gene will be inside the contig (except if new contig
                # = only 1 gene in the contig)
                if contig_num == prev_cont_num and prev_loc == "b":
                    loc = 'i'

                # If it is the first gene, we do not have any "previous gene" to write .
                # -> get new information, save it for the next gene, and go to next line
                if prev_start == "":
                    prev_start = start
                    prev_end = end
                    prev_cont_num = contig_num
                    prev_annot = annot
                    if int(strand) == 1:
                        strand = "D"
                    else:
                        strand = "C"
                    prev_strand = strand
                    continue

                # Write line in lstinfo, + header and sequence to the gene file
                _, lstline = gfunc.write_gene("CDS", locus_num, "NA", "NA", 0,
                                              prev_loc, name, prev_cont_num, "NA", prev_annot,
                                              prev_strand, prev_start, prev_end, r_lst)
                gfunc.write_header(lstline, r_gen)
                r_gen.write(seq)

                # Strands are 1/-1 in prodigal, while we use D,C -> convert, so that next time
                # we find a new gene, it writes this before updating for this new gene
                if int(strand) == 1:
                    strand = "D"
                else:
                    strand = "C"
                # Prepare variables for next gene
                locus_num += 1
                seq = ""
                prev_cont_num = contig_num
                prev_start = start
                prev_end = end
                prev_strand = strand
                prev_loc = loc
                prev_annot = annot
        # Write last sequence (-> loc = 'b')
        prev_loc = "b"
        _, lstline = gfunc.write_gene("CDS", locus_num, "NA", "NA", 0,
                                      prev_loc, name, prev_cont_num, "NA", prev_annot, prev_strand,
                                      prev_start, prev_end, r_lst)
        gfunc.write_header(lstline, r_gen)
        r_gen.write(seq)
        return True


def create_prt(prot_file, res_prot_file, res_lst_file, logger):
    """
    Generate .prt file (gembase formatted gene names), from features contained in .lst file generated just before.

    Parameters
    ----------
    prot_file : str
        .faa file generated by prodigal
    res_prot_file : str
        output file, to write in Proteins directory
    res_lst_file : str
        .lst file to get all gene names in gembase format instead of re-generating them
    logger : logging.Logger
        logger object to put information

    Returns
    -------
    bool :
        True if conversion went well, False otherwise
    """

    # Open:
    # - prot file to read gene sequences from prodigal results
    # - res_prot file to write sequences with gembase headers
    # - res_lst_file to get genes gembase names and other infos (strand, size...)

    with open(prot_file, "r") as faa, open(res_prot_file, "w") as r_prt,\
         open(res_lst_file, "r") as r_lst:
         for lineprot in faa:
            # If protein sequence, write it
            if not lineprot.startswith(">"):
                r_prt.write(lineprot)
                continue
            # If header, replace by gembase header
            linelst = r_lst.readline()
            # gembase name is in the fifth column of lst file
            start, end, _, _, gem_name, product, info = linelst.strip().split("\t")

            # Write this gembase name as a new header
            size = int(end) - int(start) + 1
            towrite = "\t".join([gem_name, str(size), product, info])
            r_prt.write(">" + towrite + "\n")


def create_rep_gff(gpath, res_rep_file, res_gff_file, res_lst_file, gff_file, name, logger):
    """
    Create replicon file by changing the headers in the input sequence.
    While changing the headers, get their name and size to put in gff file
    """
    contigs = create_replicons(gpath, res_rep_file, name)
    create_gff(gpath, gff_file, res_gff_file, res_lst_file, name, contigs, logger)


def create_replicons(gpath, res_rep_file, name):
    """
    Create Replicons file:

    Read input sequence, and replace headers with the new contig headers (found while creating
    lst and gen files)

    Parameters
        ----------
        gpath : str
            path to the genome sequence
        name : str
            genome name to use (species.date.strain)
        res_rep_file : str
            path to the new file, containing 'gpath' sequence, but with 'gembase_name' in headers
    """
    # Change headers to put into gembase format
    contigs = utils.get_genome_contigs_and_rename(name, gpath, res_rep_file)
    return contigs


def create_gff(gpath, gff_file, res_gff_file, res_lst_file, name, contigs, logger):
    """
    Create .gff3 file.

    Format:

    ##gff-version 3
    ##sequence-region contig1 start end
    ##sequence-region contig2 start end
    ...
    seqid (contig) source   type start   end score  strand phase attributes

    All fields tab separated.
    Empty fields contain '.'

    For example:
    ESCO.1017.00200.00001    Prodigal:2.6    CDS start  end .   +   .   ID=ESCO.1017.00200.b0001_00001;locus_tag=ESCO.1017.00200.b0001_00001;product=hypothetical protein


    genome1_1   Prodigal_v2.6.3 CDS 213 1880    260.0   +   0   ID=1_1;partial=00;start_type=ATG;rbs_motif=None;rbs_spacer=None;gc_cont=0.534;conf=99.99;score=259.99;cscore=268.89;sscore=-8.89;rscore=-8.50;uscore=-4.34;tscore=3.95;

    Parameters
        ----------
        gpath : str
            path to the genome sequence
        name : str
            genome name to use (species.date.strain)
        res_rep_file : str
            path to the new file, containing 'gpath' sequence, but with 'gembase_name' in headers
        prot_file : str
            .gff file generated by prodigal
        contigs : list
            list of contig names with their size. [contig1;size1, contig2;size2 ...]

    """
    with open(gff_file, 'r') as gf, open(res_gff_file, "w") as rgf, open(res_lst_file, "r") as rlf:
        rgf.write("##gff-version  3\n")
        for contig in contigs:
            cont_name, end = contig.split(";")
            rgf.write("##sequence-region\t{}\t{}\t{}\n".format(cont_name[1:], "1", end))
        for linegff in gf:
            # Ignore gff lines starting by #. These are already all written at the
            # beginning of the file.
            if linegff.startswith("#"):
                continue
            # Get all information from gff line. Strip each of them as trailing whitespace
            # can be hidden (leading to information from gff considered as different from
            # information from lst)
            fields_g = linegff.strip().split("\t")
            fields_g = [info.strip() for info in fields_g]
            (contig_name, source, type_g, start_g, end_g,
             score, strand_g, phase, attributes) = fields_g
            # Get information from next lst line (in lst, 1 line per gene. In gff, also 1 line
            # (line without #) per gene. So, informations should correspond
            linelst = rlf.readline()
            fields_l = linelst.strip().split("\t")
            fields_l = [info.strip() for info in fields_l]
            start_l, end_l, strand_l, type_l, locus_l, _, _ = fields_l
            ffn = os.path.basename(gff_file).split(".")[0]
            gff = os.path.basename(gff_file)
            if start_l.strip() != start_g.strip():
                logger.error("Files {}.ffn and {} do not have the same start value for gene {} ({} in gff, {} in ffn))".format(ffn, gff))
                return False
            else:
                logger.info("ok for " + ffn)



