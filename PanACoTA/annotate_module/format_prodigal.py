#!/usr/bin/env python3
# coding: utf-8

"""
Functions to convert prodigal result files to gembase format.

    * Proteins: multifasta with all CDS in aa
    * Replicons: multifasta of genome
    * Genes: multifasta of all genes in nuc
    * gff3: gff files without sequence
    * LSTINFO: information on annotation. Columns are: "start end strand type locus
    gene_name | product | EC_number | inference2" and strain is C (complement) or D (direct).
    Locus is: `<genome_name>.<contig_num><i or b>_<protein_num>`
    For prodigal: "start end strand type locus NA | NA | NA | NA", as no functional annotation.

@author gem
April 2019
"""

import os
import PanACoTA.annotate_module.general_format_functions as gfunc


def format_one_genome(gpath, name, prod_path, lst_dir, prot_dir, gene_dir,
                      rep_dir, gff_dir, logger):
    """
     Format the given genome, and create its corresponding files in the following folders:

    - Proteins
    - Genes
    - Replicons
    - LSTINFO
    - gff

    Parameters
    ----------
    gpath : str
        path to the genome sequence which was given to prodigal for annotation
    name : str
        gembase name of the genome
    prod_path : str
        directory where prodigal folders are saved
    name : str
        gembase name of the genome
    lst_dir : srt
        path to LSTINFO folder
    prot_dir : str
        path to Proteins folder
    gene_dir : str
        path to Genes folder
    rep_dir : str
        path to Replicons folder
    gff_dir : str
        path to gff3 folder
    logger : logging.Logger
        logger object to write log information

    Returns
    -------
    bool :
        True if genome was correctly formatted, False otherwise
    """
    prodigal_dir = os.path.join(prod_path, os.path.basename(gpath) + "-prodigalRes")
    prot_file = os.path.join(prodigal_dir, name + ".faa")
    gen_file = os.path.join(prodigal_dir, name + ".ffn")
    gff_file = os.path.join(prodigal_dir, name + ".gff")

    res_prot_file = os.path.join(prot_dir, name + ".prt")
    res_gene_file = os.path.join(gene_dir, name + ".gen")
    res_lst_file = os.path.join(lst_dir, name + ".lst")
    res_rep_file = os.path.join(rep_dir, name + ".fna")
    res_gff_file = os.path.join(gff_dir, name + ".gff")

    # First, create gen and lst files
    ok = create_gene_lst(gen_file, res_gene_file, res_lst_file, name, logger)
    if not ok:
        os.remove(res_gene_file)
        os.remove(res_lst_file)
        logger.error("Problems while generating gene and lst files for {}".format(name))
        return False
    ok = create_prt(prot_file, res_prot_file, res_lst_file, logger)
    # utils.rename_genome_contigs(gembase_name, gpath, outfile):\


def create_gene_lst(gen_file, res_gene_file, res_lst_file, name, logger):
    """
    Generate .gen file, from sequences contained in .ffn, but changing the
    headers to match with gembase format.
    At the same time, generate lst file

    Parameters
    ----------
    gen_file : str
        .ffn file generated by prodigal
    res_gene_file : str
        output file, to write in Genes directory
    res_lst_file : str
        .lst file to write in LSTINFO directory
    name : str
        name of the genome to format
    logger : logging.Logger
        logger object to put information

    Returns
    -------
    bool :
        True if conversion went well, False otherwise
    """

    # Variable which will contain the current sequence
    seq = ""
    # number of the current gene (first gene is 1, 2nd is 2 etc. each number is unique: do not
    # re-start at 1 for each new contig)
    locus_num = 1
    # contig number of the last gene. To check if we are now in a new contig (-> loc = b) or not
    prev_cont_num = 0
    # Keep start, strand and end from the previous gene, before overwriting it with the new one
    prev_start = ""
    prev_end = ""
    prev_strand = ""
    # Update loc when contig changes
    prev_loc = "b"
    loc = "b"

    # Open files: ffn prodigal to read, .gen and .lst gembase to create
    with open(gen_file, "r") as ffn, open(res_gene_file, "w") as r_gen,\
         open(res_lst_file, "w") as r_lst:
        for lineffn in ffn:
            # If it is a sequence, save it and go to next line
            if not lineffn.startswith(">"):
                seq += lineffn
                continue
            # Otherwise, write header of previous sequence, write previous sequence,
            # and update for next gene
            else:
                # Get information given for the new gene (by ffn file from prodigal)
                (gname, start, end, strand, annot) = lineffn.strip().split(">")[-1].split("#")

                # Get contig number from prodigal gene header: prodigal first part of header is:
                #  <original genome name>_<contig number>_protein number
                contig_num = int(gname.strip().split("_")[-2])
                # If first gene of a new contig, previous gene was the last of
                # its contig -> prev_loc = "b"
                if contig_num != prev_cont_num:
                    prev_loc = 'b'
                    loc = 'b'
                # If not new contig. If loc == 'b', this is the first protein of this contig
                # Next gene will be inside the contig (except if new contig
                # = only 1 gene in the contig)
                if contig_num == prev_cont_num and prev_loc == "b":
                    loc = 'i'

                # If it is the first gene, we do not have any "previous gene" to write .
                # -> get new information, save it for the next gene, and go to next line
                if prev_start == "":
                    prev_start = start
                    prev_end = end
                    prev_cont_num = contig_num
                    if int(strand) == 1:
                        strand = "D"
                    else:
                        strand = "C"
                    prev_strand = strand
                    continue

                # Write line in lstinfo, + header and sequence to the gene file
                _, lstline = gfunc.write_gene("CDS", locus_num, "NA", "NA", 0,
                                                  prev_loc, name, prev_cont_num, "NA", "NA", prev_strand, prev_start, prev_end, r_lst)
                gfunc.write_header(lstline, r_gen)
                r_gen.write(seq)

                # Strands are 1/-1 in prodigal, while we use D,C -> convert, so that next time
                # we find a new gene, it writes this before updating for this new gene
                if int(strand) == 1:
                    strand = "D"
                else:
                    strand = "C"
                # Prepare variables for next gene
                locus_num += 1
                seq = ""
                prev_cont_num = contig_num
                prev_start = start
                prev_end = end
                prev_strand = strand
                prev_loc = loc
        # Write last sequence (-> loc = 'b')
        prev_loc = "b"
        _, lstline = gfunc.write_gene("CDS", locus_num, "NA", "NA", 0,
                                              prev_loc, name, prev_cont_num, "NA", "NA", prev_strand, prev_start, prev_end, r_lst)
        gfunc.write_header(lstline, r_gen)
        r_gen.write(seq)
        return True


def create_prt(prot_file, res_prot_file, res_lst_file, logger):
    """
    Generate .prt file (gembase formatted gene names), from features contained in .lst file generated just before.

    Parameters
    ----------
    prot_file : str
        .faa file generated by prodigal
    res_prot_file : str
        output file, to write in Proteins directory
    res_lst_file : str
        .lst file to get all gene names in gembase format instead of re-generating them
    logger : logging.Logger
        logger object to put information

    Returns
    -------
    bool :
        True if conversion went well, False otherwise
    """

    # Open
    # + prot file to read gene sequences from prodigal results
    # + res_prot file to write sequences with with gembase headers
    # + res_lst_file to get genes gembase names
    with open(prot_file, "r") as faa, open(res_prot_file, "w") as r_prt,\
         open(res_lst_file, "r") as r_lst:
         for lineprot in faa:
            # If protein sequence, write it
            if not lineprot.startswith(">"):
                r_prt.write(lineprot)
                continue
            # If header, replace by gembase header
            linelst = r_lst.readline()
            # gembase name is in the fifth column of lst file
            start, end, _, _, gem_name, product, info = linelst.split("\t")[4]
            # Write this gembase name as a new header
            prt_header = "\t".join([gem_name, str(int(end) - int(start)), product, info])
            r_prt.write(">" + prt_header + "\n")



