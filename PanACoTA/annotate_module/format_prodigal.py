#!/usr/bin/env python3
# coding: utf-8

"""
Functions to convert prodigal result files to gembase format.

    * Proteins: multifasta with all CDS in aa
    * Replicons: (multi)fasta of genome sequences
    * Genes: multifasta of all genes in nuc
    * gff3: gff files without sequence
    * LSTINFO: information on annotation. Columns are: "start end strand type locus
    gene_name | product | EC_number | inference2" and strain is C (complement) or D (direct).
    Locus is: `<genome_name>.<contig_num><i or b>_<protein_num>`
    For prodigal: "start end strand type locus NA | NA | NA | NA", as there is no
    functional annotation.

@author gem
July 2019
"""

import os
import shutil

import PanACoTA.utils as utils
import PanACoTA.annotate_module.general_format_functions as gfunc


def format_one_genome(gpath, name, prod_path, lst_dir, prot_dir, gene_dir,
                      rep_dir, gff_dir, logger):
    """
    Format the given genome, and create its corresponding files in the following folders:

    - Proteins
    - Genes
    - Replicons
    - LSTINFO
    - gff

    Parameters
    ----------
    gpath : str
        path to the genome sequence which was given to prodigal for annotation
    name : str
        gembase name of the genome
    prod_path : str
        directory where all tmp_files for all sequences are saved (sequences cut at each set
        of 5N, prodigal results and logs)
    lst_dir : str
        path to LSTINFO folder
    prot_dir : str
        path to Proteins folder
    gene_dir : str
        path to Genes folder
    rep_dir : str
        path to Replicons folder
    gff_dir : str
        path to gff3 folder
    logger : logging.Logger
        logger object to write log information

    Returns
    -------
    bool :
        True if genome was correctly formatted, False otherwise
    """
    # Get directory where prodigal results for the current genome are saved
    prodigal_dir = os.path.join(prod_path, os.path.basename(gpath) + "-prodigalRes")

    # Get prodigal result files
    prot_file = os.path.join(prodigal_dir, name + ".faa")
    gen_file = os.path.join(prodigal_dir, name + ".ffn")
    gff_file = os.path.join(prodigal_dir, name + ".gff")

    # Define names for generated gembase files
    res_prot_file = os.path.join(prot_dir, name + ".prt")
    res_gene_file = os.path.join(gene_dir, name + ".gen")
    res_lst_file = os.path.join(lst_dir, name + ".lst")
    res_rep_file = os.path.join(rep_dir, name + ".fna")
    res_gff_file = os.path.join(gff_dir, name + ".gff")


    # First, create .gen and .lst files. If they could not be formatted,
    # remove those files, and return False with error message
    ok = create_gene_lst(gen_file, res_gene_file, res_lst_file, name, logger)
    if not ok:
        try:
            os.remove(res_gen_file)
            os.remove(res_lst_file)
        except OSError:
            pass
        logger.error("Problems while generating .gen and .lst files for {}".format(name))
        return False

    # Create replicon and gff files. Replicon is the same as input sequence but with
    # gembase formatted headers
    # From Replicon file, get contig names, and use them to generate gff file
    ok = create_rep_gff(gpath, res_rep_file, res_gff_file, res_lst_file, gff_file, name, logger)
    # If problem while formatting the genome (rep or gff file), remove all already created files, and return False with error message.
    if not ok:
        try:
            os.remove(res_gene_file)
            os.remove(res_lst_file)
            os.remove(res_rep_file)
            os.remove(res_gff_file)
        except OSError:
            pass
        logger.error("Problems while generating .fna (Replicons folder) and .gff (gff3 folder) "
                     "files for {}".format(name))
        return False

    # ok = create_prt(prot_file, res_prot_file, res_lst_file, logger)
    # utils.rename_genome_contigs(gembase_name, gpath, outfile):\


def create_gene_lst(gen_file, res_gen_file, res_lst_file, name, logger):
    """
    Generate .gen file, from sequences contained in .ffn, but changing the
    headers to match with gembase format.
    At the same time, generate .lst file, from the information given in prodigal ffn headers

    Parameters
    ----------
    gen_file : str
        .ffn file generated by prodigal
    res_gen_file : str
        generated .gen file, to write in Genes directory
    res_lst_file : str
        generated .lst file to write in LSTINFO directory
    name : str
        gembase name of the genome to format
    logger : logging.Logger
        logger object to put information

    Returns
    -------
    bool :
        True if conversion went well, False otherwise
    """

    # Variable which will contain the current gene sequence
    seq = ""
    # number of the current gene (first gene is 1, 2nd is 2 etc. each number is unique: do not
    # re-start at 1 for each new contig)
    locus_num = 1
    # contig number of the last gene. To check if we are now in a new contig (-> loc = b) or not
    prev_cont_num = 0
    # Keep start, end, strand and informations (prodigal gives information on start_type,
    # gc_cont etc.) from the previous gene, before overwriting it with information
    # on the new one
    prev_start = ""
    prev_end = ""
    prev_strand = ""
    prev_info = ""
    # Update loc when contig changes ('b' if gene at the border of a contig, 'i' if it is inside)
    prev_loc = "b"
    # To start, the first gene is, by definition, at the border of the contig
    loc = "b"

    # Open files: .ffn prodigal to read, .gen and .lst gembase to create
    with open(gen_file, "r") as ffn, open(res_gen_file, "w") as r_gen,\
         open(res_lst_file, "w") as r_lst:
        # Read all lines in ffn file (sequences in nuc. for each gene)
        for lineffn in ffn:
            # If it is a sequence, save it and go to next line
            if not lineffn.startswith(">"):
                seq += lineffn
                continue
            # Otherwise:
            # - write header of previous sequence to .gen
            # - write previous sequence (in 'seq') to .gen
            # - write LSTINFO information to .lst
            # - update information (new start, end, contig number etc.) for next gene
            else:
                # Get information given for the new gene (by .ffn file from prodigal)
                (gname, start, end, strand, info) = lineffn.strip().split(">")[-1].split("#")
                # Get contig number from prodigal gene header: prodigal first part of header is:
                #  <original genome name>_<contig number>_<protein number>
                contig_num = int(gname.strip().split("_")[-2])

                # If new contig:
                # - previous gene was the last of its contig -> prev_loc = "b" ;
                # - the current gene is the first of its contig (loc = "b")
                if contig_num != prev_cont_num:
                    prev_loc = 'b'
                    loc = 'b'
                # If not new contig. If prev_loc == 'b', previous gene is the first protein
                # of this contig.
                # Current gene will be inside the contig (except if new contig for the next gene,
                # meaning only 1 gene in the contig)
                if contig_num == prev_cont_num and prev_loc == "b":
                    loc = 'i'

                # If it is the first gene of the genome, we do not have any "previous gene"
                # to write .
                # -> get new information, save it for the next gene, and go to next line
                if prev_start == "":
                    prev_start = start
                    prev_end = end
                    prev_cont_num = contig_num
                    prev_info = info
                    # Convert strand 1/-1 to D/C
                    if int(strand) == 1:
                        strand = "D"
                    else:
                        strand = "C"
                    prev_strand = strand
                    continue

                # Write line in LSTINFO file, + header and sequence to the gene file
                _, lstline = gfunc.write_gene("CDS", locus_num, "NA", "NA", 0,
                                              prev_loc, name, prev_cont_num, "NA", prev_info,
                                              prev_strand, prev_start, prev_end, r_lst)
                gfunc.write_header(lstline, r_gen)
                r_gen.write(seq)

                # Strands are 1/-1 in prodigal, while we use D,C -> convert, so that next time
                # we find a new gene, it writes this before updating for this new gene
                if int(strand) == 1:
                    strand = "D"
                else:
                    strand = "C"
                # Prepare variables for next gene
                locus_num += 1
                seq = ""
                prev_cont_num = contig_num
                prev_start = start
                prev_end = end
                prev_strand = strand
                prev_loc = loc
                prev_info = info
        # Write last gene of the genome (-> loc = 'b')
        prev_loc = "b"
        _, lstline = gfunc.write_gene("CDS", locus_num, "NA", "NA", 0,
                                      prev_loc, name, prev_cont_num, "NA", prev_info, prev_strand,
                                      prev_start, prev_end, r_lst)
        gfunc.write_header(lstline, r_gen)
        r_gen.write(seq)
        return True


def create_rep_gff(gpath, res_rep_file, res_gff_file, res_lst_file, gff_file, name, logger):
    """
    Create replicon file by changing the headers in the input sequence.
    While changing the headers, get their name and size to put in gff file.

    Then, create gff file with the gene names and contig sizes

    Parameters
    ----------
        gpath : str
            path to the genome sequence
        res_rep_file : str
            path to the new file, containing 'gpath' sequence, but with 'gembase_name' in headers
        res_gff_file : str
            path to the gff file that must be created in result database
        res_lst_file : str
            path to the lst file that was created in result database in the previous step
        gff_file : str
            path to gff file generated by prodigal
        name : str
            genome name to use (species.date.strain)
        logger : logging.Logger
            logger object to put information

    Returns
    -------
    bool :
        True if everything went well, False otherwise

    """
    contigs = create_replicons(gpath, res_rep_file, name)
    # if contigs:
    #     return create_gff(gpath, gff_file, res_gff_file, res_lst_file, name, contigs, logger)
    return contigs


def create_replicons(gpath, res_rep_file, name):
    """
    Create Replicons file:

    Read input sequence, and replace headers with the new contig headers (found while creating
    lst and gen files)

    Parameters
    ----------
        gpath : str
            path to the genome sequence
        res_rep_file : str
            path to the new file, containing 'gpath' sequence, but with 'gembase_named' headers
        name : str
            genome name to use (species.date.strain)

    Returns
    -------
    list :
        List of all contigs with their size ["contig1;size1", "contig2;size2" ...]

    """
    # Change headers of replicon file to put into gembase format, and save it in res_rep_file
    contigs = utils.get_genome_contigs_and_rename(name, gpath, res_rep_file)
    # Return each contig name with its size.
    return contigs


def create_gff(gpath, gff_file, res_gff_file, res_lst_file, name, contigs, logger):
    """
    Create .gff3 file.

    Format:

    ##gff-version 3
    ##sequence-region contig1 start end
    ##sequence-region contig2 start end
    ...
    seqid(=contig) source   type start   end score  strand phase attributes

    All fields tab separated.
    Empty fields contain '.'

    For example:
    ESCO.1017.00200.00001    Prodigal:2.6    CDS start  end .   +   .   ID=ESCO.1017.00200.b0001_00001;locus_tag=ESCO.1017.00200.b0001_00001;product=hypothetical protein


    genome1_1   Prodigal_v2.6.3 CDS 213 1880    260.0   +   0   ID=1_1;partial=00;start_type=ATG;rbs_motif=None;rbs_spacer=None;gc_cont=0.534;conf=99.99;score=259.99;cscore=268.89;sscore=-8.89;rscore=-8.50;uscore=-4.34;tscore=3.95;

    Parameters
    ----------
        gpath : str
            path to the genome sequence given to prodigal
        res-gff_file : str
            path to the gff file that must be created in result database
        res-lst_file : str
            path to the lst file that was created in result database in the previous step
        name : str
            genome name to use (species.date.strain)
        contigs : list
            list of contig names with their size. ["contig1"\t"size1", "contig2"\t"size2" ...]
        logger : logging.Logger
            logger object to put information

    Returns
    -------
    bool
        True if everything went well, False if any problem

    """
    # open gff generated by prodigal to read it
    # open file to write new gff file
    # open lst file to read all information saved from prodigal results
    with open(gff_file, 'r') as gf, open(res_gff_file, "w") as rgf, open(res_lst_file, "r") as rlf:
        # Write header of gff3 file
        rgf.write("##gff-version  3\n")
        for contig in contigs:
            # Write the list of contigs, with their size
            cont_name, end = contig.split("\t")
            rgf.write("##sequence-region\t{}\t{}\t{}".format(cont_name[1:], "1", end))
        for linegff in gf:
            iter_contig = iter(contigs)
            contig = next(iter_contig)
            # Ignore gff lines starting by #. For the new gff, these are already all written at the
            # beginning of the file.
            if linegff.startswith("#"):
                continue
            # Get all information from prodigal gff line. Strip each of them as trailing whitespace
            # can be hidden (leading to information from gff considered as different from
            # information from lst)
            fields_g = linegff.strip().split("\t")
            fields_g = [info.strip() for info in fields_g]
            (contig_name, source, type_g, start_g, end_g,
             score, strand_g, phase, attributes) = fields_g
            # Get information given to this same sequence from the lst file
            # (next lst line corresponds to next gff line without #), as, for each format,
            # there is 1 line per gene)
            linelst = rlf.readline()
            fields_l = linelst.strip().split("\t")
            fields_l = [info.strip() for info in fields_l]
            start_l, end_l, strand_l, type_l, locus_l, _, _ = fields_l
            cname = contig.split("\t")[0][1:]


            # Get gff and ffn filenames to give information to user if error message
            gff = os.path.basename(gff_file)
            ffn = ".".join(gff.split(".")[:-1]) + ".ffn"
            # Path where gff and ffn generated by prodigal are
            tmp = gpath + "-prodigalRes"
            # Get gene name given by prodigal to current gene
            gname = attributes.split("ID=")[1].split(";")[0]

            # Compare information from lst and information from prodigal gff (start,
            # end and type of feature). They should correspond
            for (elemg, eleml, label) in zip([start_g, end_g, type_g],
                                             [start_l, end_l, type_l],
                                             ["start", "end", "type"]):
                # If 1 element is different (start or end position, or type), print error
                # message and return False: this genome could not be converted to gff
                if elemg != eleml:
                    logger.error("Files {} and {} (in prodigal tmp_files: {}) do not have the same {} value for gene {}"
                                 " ({} in gff, {} in ffn))".format(ffn, gff, tmp, label,
                                                                   gname, elemg, eleml))
                    return False
                # Replace prodigal ID with the new gene name (in gembase format), found in the
                # corresponding lst line
                at_split = attributes.split(";")
                new = [atr if "ID" not in atr else 'ID={}'.format(locus_l) for atr in at_split]
                # Get information to put to the new gff line
                # Get contig name without '>'
                info = "\t".join([cname, source, type_g, start_g, end_g, score, strand_g, phase, ";".join(new)])
                rgf.write(info + "\n")
    return True


def create_prt(prot_file, res_prot_file, res_lst_file, logger):
    """
    Generate .prt file (gembase formatted gene names), from features contained in .lst file generated just before.

    Parameters
    ----------
    prot_file : str
        .faa file generated by prodigal
    res_prot_file : str
        output file, to write in Proteins directory
    res_lst_file : str
        .lst file to get all gene names in gembase format instead of re-generating them
    v
    Returns
    -------
    bool :
        True if conversion went well, False otherwise
    """

    # Open:
    # - prot file to read gene sequences from prodigal results
    # - res_prot file to write sequences with gembase headers
    # - res_lst_file to get genes gembase names and other infos (strand, size...)

    with open(prot_file, "r") as faa, open(res_prot_file, "w") as r_prt,\
         open(res_lst_file, "r") as r_lst:
         for lineprot in faa:
            # If protein sequence, write it
            if not lineprot.startswith(">"):
                r_prt.write(lineprot)
                continue
            # If header, replace by gembase header
            linelst = r_lst.readline()
            # gembase name is in the fifth column of lst file
            start, end, _, _, gem_name, product, info = linelst.strip().split("\t")

            # Write this gembase name as a new header
            size = int(end) - int(start) + 1
            towrite = "\t".join([gem_name, str(size), product, info])
            r_prt.write(">" + towrite + "\n")
